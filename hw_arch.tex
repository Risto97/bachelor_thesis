\section{Arhitektura hardvera}

\subsection{Uvod}\label{hw_arch_intro}

U ovom poglavlju biće opisana arhitektura hardvera koja je projektovana. \\
Postoje razlike između implementiranih arhitektura u SystemVerilog-u i PyGears-u. \\
Pošto obe metodologije sa sobom nose neke karakteristike koje otežavaju ili
olakšavaju određene principe prilikom projektovanja, ove razlike će biti opisane
u kasnijim poglavljima. \\

Iako su razlike između ove dve implementacije male opis u ovom poglavlju će biti
bliži implementaciji u PyGears-u koja je novija i ispravljene su neke sistemske
greške. \\

Arhitektura će biti opisana na nivou modula od kojih se sastoji njihovih
portova, funkcija koje obavljaju i eventualno kritičnih funkcionalnih i memorijskih jedinica.

\begin{figure}[H]
\centering{
  \scalebox{0.8}{
    \input{images/tikz/hw_arch.tex}
  }}
\caption{Arhitektura hardvera kaskadnog klasifikatora}
\label{hw_arch_top}
\end{figure}

Na slici(\ref{hw_arch_top}) prikazan je uprošćen blok dijagram realizovanog IP jezgra.

\subsection{Interfejsi IP jezgra}
\emph{IP} jezgro se povezuje pomoću 3 interfejsa:

\begin{itemize}
  \item Ulazni interfejs \textbf{img\_in} sastoji se od 8-bitnog podatka
    vrednosti piksela slike u \emph{grayscale} formatu (nijanse sive).
  \item Izlazni interfejs \textbf{detect\_addr} ukoliko jezgro detektuje lice na slici
    postaviće x i y koordinate na ovom interfejsu.
  \item Izlazni interfejs \textbf{irq} je signal koji označava završetak obrade slike i
    signalizira da je jezgro spremno za novu sliku.
    Namenjen da se koristi kao prekidni signal za procesor.
\end{itemize}

\subsection{Modul IMG RAM}

Modul \textbf{IMG RAM} je zadužen za skladištenje slike koja se obrađuje.
Sastoji se od RAM memorije i brojača za generisanje adrese za upis. \\
Nakon primljenog podatka na ulazu brojač adrese upisa se poveća za 1. \\
Skladištena slika je u 8-bitnom formatu i predstavlja grayscale vrednost piksela
originalne slike. \\
Veličina memorije je $width*height*8$ bit. Za dimenziju slike 240x320
veličina memorije je $614400$ bita. \\

Komunicira sa okolinom pomoću 3 interfejsa:
\begin{itemize}
  \item Ulazni interfejs \textbf{img\_in} ekvivalentan je sa istoimenim
    interfejsom na višem nivou hijerarhije.
  \item Ulazni interfejs \textbf{rd\_addr} predstavlja linearnu adresu
    generisanu od strane \textbf{rd\_addrgen} modula. Koristi se za čitanje
    podataka iz RAM memorije.
  \item Izlazni interfejs \textbf{img\_out} predstavlja iščitane podatke iz RAM memorije.
\end{itemize}

\subsection{Modul rd\_addrgen}

Modul \textbf{rd\_addrgen} je zadužen za generisanje adrese za čitanje iz
\textbf{img\_ram} modula. \\
Blok dijagram ovog modula prikazan je na slici (\ref{rd_addrgen_bd}). \\

\begin{figure}[H]
    \input{images/tikz/rd_addrgen.tex}
\caption{Blok dijagram \textbf{rd\_addrgen} modula}
\label{rd_addrgen_bd}
\end{figure}

Pored generisanja adrese pomoću ovog modula je dodatno rešeno i skaliranje slike opisano u sekciji
\ref{image_scaling}. \\

\subsubsection{Scale\_counter}\label{scale_counter_sec}
\textbf{Scale\_counter} je brojač koji se poveća za jedan kada klasifikator
završi obradu slike na trenutnom nivou piramide prikazanoj na slici
(\ref{image_pyramid}) sekciji \ref{image_scaling}. \\

\subsubsection{Boundaries}\label{boundaries_sec}
\textbf{Boundaries} kao ulaz dobija trenutni stepen skaliranja
\textbf{scale\_num} i na osnovu njega na izlazu daje \textbf{X} i \textbf{Y} granice do kojih
\textbf{hopper} treba da broji.
Ove granice osiguravaju ispravno generisanje adrese, odnosno obezbeđuju da
izlazna adresa nikad ne iskoči iz opsega \textbf{img\_ram} memorije. \\
Realizovan je pomoću multipleksera i softverski izračunatih konstantnih
vrednosti granica. \\

\subsubsection{Scale\_ratio}\label{scale_ratio_sec}
\textbf{Scale\_ratio} ima ulogu da dostavi \textbf{sweeper}-u potrebne parametre za
računanje skalirane adrese.
Realizovan je isto kao i \textbf{boundaries} modul. \\

\subsubsection{Hopper}\label{hopper_sec}
\textbf{Hopper} se može zamisliti kao dvostruka ugnježdena for petlja gde
iteratori petlje predstavljaju koordinate \textbf{X} i \textbf{Y}. \\
Prvo se iterira po \textbf{X} kordinati pa po \textbf{Y}.

\begin{lstlisting}[language=C++,caption={Primer \textbf{hopper}-a u \textbf{C}-u},captionpos=b, label=hopper_code]
  for(int y = 0; y < boundary_y[scale_num]; y++){
    for(int x = 0; x < boundary_x[scale_num]; x++){
      // Sweeper
    }
  }
\end{lstlisting}

Na primeru (\ref{hopper_code}) prikazana je implementacija \textbf{hopper}-a u
\textbf{C}-u.
Može se videti da granice \textbf{hopper}-a zavise od promenljivih
\textbf{boundary\_x} i \textbf{boundary\_y} koji se indeksiraju preko
\textbf{scale\_num} promenljive opisane u sekcijama (\ref{boundaries_sec},
\ref{scale_counter_sec}). \\

Na slikama (\ref{hop_sweep1}, \ref{hop_sweep2}) je prikazan rad hopper-a i
sweeper-a.
Plavi kružići predstavljaju piksele za koje će
rd\_addrgen generisati adresu za trenutno stanje hopper-a. \\
Gornji levi kružić je koordinata trenutnog položaja hopper-a.
Crevnom strelicom je obeleženo iteriranje hopper-a kroz sliku. \\
Na slici (\ref{hop_sweep2}) može se videti trenutak kada hopper dostiže granicu
boundary\_x nakon čega prelazi u novi red, uvećava Y koordinatu a X koordinatu
postavlja na početni položaj. \\

Nakon što hopper dostigne obe granice boundary\_x i boundary\_y završen je
trenutni stepen skaliranja slike i potrebno je uvećati scale\_num za jedan.

\begin{figure}[H]
  \centering
  \scalebox{0.82}{
    \input{images/tikz/hop_sweep/hop_sweep1.tex}
    \input{images/tikz/hop_sweep/hop_sweep2.tex}
    }
\caption{Način rada \textbf{hopper} i \textbf{sweeper} komponenti.}
\label{hop_sweep1}
\end{figure}


\begin{figure}[H]
  \centering
  \scalebox{0.82}{
    \input{images/tikz/hop_sweep/hop_sweep3.tex}
    \input{images/tikz/hop_sweep/hop_sweep4.tex}
    }
\caption{Prelazak \textbf{hopper}-a u novi red.}
\label{hop_sweep2}
\end{figure}

\newpage

\subsubsection{Sweeper}\label{sweeper_sec}
Slično kao hopper i sweeper se može predstaviti kao dve ugnježdene for petlje. \\
Ponovo se prvo iterira po X koordinati pa onda po Y.

\begin{lstlisting}[language=C++,caption={Primer \textbf{sweeper}-a u \textbf{C}-u},captionpos=b, label=sweeper_code]
  int x, y;
  // hopper
  for(int hop_y = 0; hop_y < boundary_y[scale_num]; hop_y++){
    for(int hop_x = 0; x < boundary_x[scale_num]; hop_x++){
      // sweeper
      for(y = hop_y; y < hop_y+feature_height; y++){
        for(x = hop_x; x < hop_x+feature_width; x++){
          // scale address
          // translate to linear address
        }
      }
    }
  }
\end{lstlisting}

Kao što se vidi na primeru (\ref{sweeper_code}) hopper i sweeper se zajedno mogu
predstaviti kao četiri ugnježdene for petlje. \\
Sweeper će početnu vrednost svojih X i Y promenljivih uzeti od trenutne
vrednosti hopper koordinata, zatim će se iterirati feature\_width i
feature\_height puta. \\
Na slikama (\ref{hop_sweep1}, \ref{hop_sweep2}) prelazak sweeper-a po slici je
prikazan horizontalnim i dijagonalnim strelicama.
Dok je plavim kružićima predstavljeni pikseli koje sweeper prebriše za jedan
položaj hopper-a.

\newpage

\subsubsection{Skaliranje adrese}\label{address_scaling_sec}

Unutar sweeper-a je implementirano i skaliranje adrese u svrhu skaliranja slike
objašnjeno u sekciji \ref{image_scaling}. \\
Potrebno je množiti adresu sa decimalnim faktorom (npr. $1.2$, $1.33$), kako je
u hardveru množenje sa decimalnim brojevima sa pokretnom tačkom skupa operacija,
efikasnije je odraditi množenje sa fiksnom tačkom. \\
To je odrađeno tako što celobrojni faktor unapred softverski izračunat i smešten
u scale\_ratio modul, isto tako je i broj pomeranja u desno dobijene binarne
vrednosti unapred poznat.
Pa je jednostavno odraditi množenje sa fiksnom tačkom. \\

Ovako skalirana adresa prikazana je na slici (\ref{hop_sweep_scale}).
Može se videti da će u ovom slučaju svaka četvrta tačka biti preskočena.
Na taj način će se dobiti manja slika od originalne, u ovom primeru od početne
slike $10*10$ dobija se slika $8*8$. \\
Na taj način objekti koji su izgledali veći na originalnoj slici će izgledati
manji na skaliranoj slici, što nam je potrebno kako bi dobili invarijantnost
veličine opisane u sekciji \ref{image_scaling}.

\begin{figure}[H]
  \centering
  \scalebox{0.7}{
    \input{images/tikz/hop_sweep/hop_sweep_scale.tex}
    }
\caption{Posledica skaliranja adrese.}
\label{hop_sweep_scale}
\end{figure}

\subsubsection{Modul addr\_trans}\label{addr_trans_sec}

Konačno je potrebno konvertovati adresu predstavljenu koordinatama (y, x) u
linearnu adresu, pošto se RAM memorija adresira linearno. Ovo obavlja
addr\_trans u hardveru. \\
Translaciju je jednostavno uraditi pomoću seledeće formule.

\begin{equation}
  \Scale[1.2]{lin\_addr = (y * img\_width) + x}
  \label{IntegralImage_eq2}
\end{equation}

Gde su y i x koordinate iz sweeper-a a img\_width je parametar koji označava
širinu slike.

\newpage

\subsection{Modul ii\_gen i sii\_gen} \label{ii_sii_gen_sec}

\subsubsection{Odabir algoritma}\label{ii_alg_sel_sec}

Jedan od kritičnih delova Viola-Jones algoritma je generisanje integralne slike
opisane u poglavlju \ref{ii_sec}. \\
Isto tako se ispostavlja da i u hardverskoj implementaciji generisanje
integralne slike ima veliki uticaj na performanse i potrebne hardverske resurse sistema. \\

Kao izbor možemo izabrati sekvencijalni ili paralelni algoritam. \\
Ukoliko bi se odabrao paralelni algoritam koji može da računa više piksela u paraleli
povećanje resursa bi se drastično odrazilo na img\_ram i frame\_buffer memorije.
Ali bi dobili bolje performanse sistema. \\
Kako bi implementacija paralelnog algoritma povećala kompleksnost ne samo ovog
modula nego i okolnih komponenti, u ovom projektu on neće biti razmatran.

\subsubsection{Sekvencijalna implementacija generatora integralne slike}\label{ii_seq_alg_sec}

U ovoj arhitekturi odabran je sekvencijalni algoritam generisanja integralne
slike koji odgovara jednačini(\ref{IntegralImage_eq2}) iz sekcije \ref{ii_sec}.
\\
Prednosti ovog algoritma u odnosu na paralelni je manji memorijski zahtevi na
ulazu i izlazu, potrebno manje funkcionalnih jedinica i unutrašnje memorije. A
mana je manja brzina. \\
Konkretno ovaj algoritam može da izračuna jedan piksel svaki takt. \\

\begin{figure}[H]
  \centering
  \scalebox{1.0}{
    \input{images/tikz/ii_gen.tex}
    }
\caption{Blok dijagram ii\_gen modula}
\label{ii_gen}
\end{figure}

Na slici(\ref{ii_gen}) prikazana je uprošćena šema generatora integralne slike.
\\

Na ulazu module je port img\_in koji predstavlja piksele slike pročitane iz
img\_ram memorije. \\

Pikseli u redu se akumuliraju pomoću sabirača i registra unutar accum modula.
Na slici je izostavljeno da se registar dreg resetuje posle dolaska poslednjeg
piksela u redu slike. \\

Nakon toga akumulirana vrednost se sabira sa vrednošću FIFO bafera koji sadrži
vrednost piksela integralne slike iz predhodnog reda.
Zatim prosleđuje na izlaz i ponovo upisuje u FIFO bafer kao vrednost izračunate
integralne slike.\\

\noindent
Zbog potreba algoritma FIFO bafer je modifikovan na sledeći način:
\begin{itemize}
  \item Dodat je PRELOAD parametar koji pomera pokazivač za upis na vrednost
    širine prozora (feature\_width) prilikom reseta. Ovo je potrebno da bi se
    obezbedilo čitanje nula iz bafera kada se obrađuje prvi red slike.
  \item FIFO se resetuje kada je završeno računanje celog prozora.
\end{itemize}

\subsubsection{Generator kvadratne integralne slike}\label{sii_gen_sec}

Generator kvadratne integralne slike je potreban za računanje standardne
devijacije prozora što je opisano u sekciji \ref{lumi_inv_sec}. \\
Generisanje kvadratne integralne slike je jednostavno uz gotov generator
integralne slike.
Potrebno je kvadrirati ulazne piksele i dovesti ih na generator integralne slike
kao na slici(\ref{sii_gen}).

\begin{figure}[H]
  \centering
  \scalebox{1.0}{
    \input{images/tikz/sii_gen.tex}
    }
\caption{Blok dijagram ii\_gen modula}
\label{sii_gen}
\end{figure}

\newpage

\subsection{Modul frame\_buffer}

Potrebno je obezbediti da se generisana integralna slika može pročitati od
strane klasifikatora u nasumičnom maniru.
Kako bi se to obezbedilo potrebno je skladištiti integralnu sliku u lokalnu RAM
memoriju. \\

\begin{figure}[H]
  \centering
  \scalebox{1.0}{
    \input{images/tikz/frame_buffer.tex}
    }
\caption{Blok dijagram frame\_buffer-a realizovanog sa 3 jedno-portne RAM memorije.}
\label{frame_buffer_bd}
\end{figure}

U ovu svrhu je projektovana komponenta frame\_buffer.
Sastoji se od brojača za adresu upisa i RAM memorije.
Brojač adrese upisa se inkremetuje za jedan nakon svakog primljenog podatka. \\
Potrebna veličina RAM memorije je data sledećim vezama:

\begin{equation}
  \Scale[1.2]{ size(bit) = frame\_width * frame\_height * w\_ii}
  \label{frame_buffer_eq1}
\end{equation}

\begin{equation}
  \Scale[1.2]{ w\_ii = ceil(log_2(frame\_width * frame\_height * 2^{w\_img}))}
  \label{frame_buffer_eq2}
\end{equation}

Gde je frame\_width i frame\_height širina i visina obeležja modela, w\_ii je
širina magistrale integralne slike, a w\_img ulazna širina magistrale piksela
slike. \\

Radi ubrzavanja rada klasifikatora možemo računati sva tri pravougaonika (\ref{haar_features_sec}) u paraleli.
Da bi se to obezbedilo potrebno je čitati u istom taktu tri vrednosti iz
frame\_buffer memorije.
Kako je više-portna memorija skupa i retko se nalazi u FPGA čipovima moguće
rešenje je koristiti tri jedno-portne memorije.
Ovo će kao rezultat zauzeti tri puta više RAM memorije na čipu.\\

Alat za sintezu uglavnom može da odradi transformaciju i da od jedne tro-portne
memorije napravi tri jedno-portne.
Ali se preporučuje da se ekslicitno instancioniraju tri memorije i pridržava
Synthesis Guideline-a npr. Xilinx \cite{XST}. \\
Primer prikazan na slici(\ref{frame_buffer_bd}).

\subsection{Modul stddev}

Računanje standardne devijacije prozora je potrebno kako bi se smanjio uticaj
različitog osvetljenja lica na slikama. \\
Za ovo je zadužen modul stddev. U sledećem primeru prikazano je računanje
standardne devijacije u C-u.

\begin{lstlisting}[language=C++,caption={Primer računanja standardne devijacije u \textbf{C}-u},captionpos=b, label=stddev_code]
  long calcStddev(long sii[FRAME_HEIGHT][FRAME_WIDTH],
                  long ii[FRAME_HEIGHT][FRAME_WIDTH]){

    long mean, stddev;

    mean = ii[0][0] + ii[FRAME_HEIGHT-1][FRAME_WIDTH-1] - ii[0][FRAME_WIDTH-1] - ii[FRAME_HEIGHT-1][0];

    stddev = sii[0][0] + sii[FRAME_HEIGHT-1][FRAME_WIDTH-1] - sii[0][FRAME_WIDTH-1] - sii[FRAME_HEIGHT-1][0];

    stddev = (stddev * (FRAME_WIDTH-1)*(FRAME_HEIGHT-1));
    stddev = stddev - (mean*mean);
    stddev = getSqrt(stddev);
    return stddev;
  }
\end{lstlisting}

Za računanje standardne devijacije potrebni su nam ivice prozora integralne i
kvadratne integralne slike, što se vidi u liniji 6 i 8
primera(\ref{stddev_code}). \\
Sabiranjem gornjeg levog i donjeg desnog piksela zatim oduzimanje gornjeg desnog
i donjeg levog integralne slike dobijamo sumu piksela celog prozora. \\
Ako pogledamo primer u C-u vidimo da imamo operacije sabiranja, oduzimanja,
kvadriranja  promenljivih, zatim množenje sa konstantom. \\
Sa ovim operacijama većina alata za sintezu nema problem prilikom mapiranja i
većina FPGA čipova ima potrebne funkcionalne jedinice. \\

Konačno potrebno je odraditi kvadratni koren u liniji 12. \\
Ovo je operacija koju većina alata za automatsku sintezu ne mogu implementirati
na FPGA čipovima, pa je potrebno pronaći dobru aproksimaciju. \\

U ovom projektu je odlučeno koristiti lookup tabelu. \\
Za unapred definisani opseg vrednosti operanda za korenovanje softverski su
izračunate vrednosti kvadratnog korena i smeštene u listu. \\
Prilikom softverske analize odlučeno je da je 256 vrednosti korena dovoljno za ispravan
rad celog sistema, uz minimalan gubitak pouzdanosti. \\

\begin{figure}[H]
  \centering
  \scalebox{0.9}{
    \input{images/tikz/stddev.tex}
    }
\caption{Blok dijagram stddev modula.}
\label{stddev_bd}
\end{figure}

Na slici(\ref{stddev_bd}) prikazan je blok dijagram projektovanog hardverskog
modula na osnovu primera(\ref{stddev_code}}).
Operaciju sabiranja piksela unutar prozora obavljaju frame\_sum moduli.
Mogu se videti i operator kvadriranja, množenja zatim i oduzimanja kao u
prethodnom primeru. \\
Lookup tabela je implementirana kao ROM memorija, nazvana SQRT\_ROM sa 256 lokacija.

\subsection{Modul features\_mem} \label{features_meme_sec}

Svako obeležje u modelu se sastoji od najviše tri pravougaonika što je
objašnjeno u sekciji \ref{haar_features_sec}. \\
Svaki pravougaonik je definisan sa četiri koordinate (A, B, C, D) i sa težinom
njegove površine. \\

Zbog uštede memorije u hardverskoj implementaciji, moguće je svaki pravougaonik predstaviti koordinatom jedne njegove tačke zatim
širinom i visinom pravougaonika.
Ostale tačke je moguće izračunati pomoću ovih podataka. \\
Na ovaj način se vrši ušteda memorije, ali se uvodi potreba za množačima i
sabiračima u hardveru.
U ovom slučaju zbog velikog broja obeležja (2913 u testiranom modelu \ref{haarcascade_frontal_sec}) ušteda
memorije je značajna, a dodatni sabirači i množači ne unose veliku cenu u sistem.

\begin{figure}[H]
  \centering
  \scalebox{0.8}{
    \input{images/tikz/rect_mem_unpack.tex}
    }
\caption{Reprezentacija pravougaonika u obeležju.}
\label{rect_repr_graph}
\end{figure}

Sa slike(\ref{rect_repr_graph}) mogu se videti potrebni parametri za
reprezentaciju pravougaonika. \\
Kao referentu koordinatu izabrana je tačka A od koje se meri širina i visina
pravougaonika kao na slici. \\
Kako je za adresiranje podatka iz RAM-a potrebna linearna adresa kao što je
objašnjeno u sekciji(\ref{addr_trans_sec}) koordinata tačke A je linearizovana u
softveru. \\
Ostale koordinate moguće je dobiti na sledeći način:

\setlength{\belowdisplayskip}{0pt} \setlength{\belowdisplayshortskip}{0pt}
\setlength{\abovedisplayskip}{0pt} \setlength{\abovedisplayshortskip}{0pt}

\begin{equation}
    \Scale[1.1]{ B = A * width}
    \label{rects_calc_coords_B}
\end{equation}
\begin{equation}
  \Scale[1.1]{ D = (A + width) + (height * FRAME\_WIDTH)}
  \label{rects_calc_coords_D}
\end{equation}
\begin{equation}
  \Scale[1.1]{ C = (A + width) + (height * FRAME\_WIDTH) - width}
  \label{rects_calc_coords_C}
\end{equation}


\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\begin{center}
  \centering
    \begin{tabular}{| P{1.5cm} | P{2.5cm} | P{2cm} | P{2cm} | P{4cm} |}
    \hline
     N & Packed value(20 bit) & Height (5bit) & Width (5bit) & A linear coord (10bit) \\ \hline
      0 &0x1A989 & 9 & 12 & 106 \\ \hline
      1 &0x1A987 & 7 & 12 & 106 \\ \hline
      2 &0x39249 & 9 & 18 & 228 \\ \hline
      3 &0x72926 & 19 & 9 & 458 \\ \hline
      $.$ & $.$ & $.$ & $.$ & $.$ \\
      $.$ & $.$ & $.$ & $.$ & $.$ \\
      $.$ & $.$ & $.$ & $.$ & $.$ \\ \hline
      feature num - 1 &0x088d6 & 22 & 6 & 34 \\ \hline
    \end{tabular}
    \captionof{table}{Struktura memorije rect\_ROM0 za model \ref{haarcascade_frontal_sec}} \label{rect_rom_struct}
\end{center}

Na tabeli(\ref{rect_rom_struct}) je prikazana strukura zapakovane memorije
rect\_ROM \\
U prvoj koloni \textbf{N} su adrese lokacija, kojih ima features\_num (2913 u modelu
\ref{haarcascade_frontal_sec}). \\
U drugoj koloni \textbf{Packed value(20 bit)} je zapakovana vrednost memorijske lokacije na
adresi u heksadecimalnom zapisu. \\
U trećoj i četvrtoj koloni se nalaze \textbf{height} i \textbf{width}
raspakovane vrednosti visine i širine pravougaonika. \\
U poslednjoj koloni se nalazi \textbf{A linear coord} raspakovana vrednost
linearne koordinate A. \\

Pored rect\_ROM memorije potrebna je weight\_ROM memorija koja će čuvati
vrednosti težina za svaki pravougaonik.

\begin{figure}[H]
  \centering
  \scalebox{0.8}{
    \input{images/tikz/features_mem.tex}
    }
\caption{Blok dijagram features\_mem modula.}
\label{features_mem_bd}
\end{figure}

Na slici(\ref{features_mem_bd}) je prikazan uprošćen blok dijagram features\_mem
modula. \\
Komponenta \textbf{feature\_counter} generiše adresu za čitanje iz ROM memorija.
\\
Postoje po 3 \textbf{rect\_ROM} i \textbf{weight\_ROM} memorije prethodno
opisane, po jedna za svaki pravougaonik u obeležju. \\
Komponenta \textbf{calc\_coords} vrši raspakivanje memorije opisane u
tablici(\ref{rect_rom_struct}) na način opisan
formulama(\ref{rects_calc_coords_B}, \ref{rects_calc_coords_D},
\ref{rects_calc_coords_C}}). \\

Konačno može se izračunati potrebna memorija u slučaju modela opisanog u
sekciji(\ref{haarcascade_frontal_sec}). \\

\newcommand{\featureNum}{2913}
\newcommand{\rectNum}{3}
\newcommand{\wWeight}{3}
\newcommand{\wRect}{20}
\FPeval{\result}{clip(\featureNum*\rectNum*\wWeight*\wRect)}

\begin{center}
  \centering
    \begin{tabular}{| P{3.0cm} | P{3.0cm}|}
    \hline
     \textbf{feature\_num} & \featureNum{}  \\ \hline
     \textbf{rect\_num} & \rectNum{}  \\ \hline
     \textbf{w\_weight} & \wWeight{} bits  \\ \hline
     \textbf{w\_rect} & \wRect{} bits  \\ \hline
      \cellcolor{green!35} \textbf{TOTAL} & \cellcolor{green!35} \result{} bits \\ \hline
    \end{tabular}
    \captionof{table}{Veličina memorije features\_mem za model \ref{haarcascade_frontal_sec}} \label{feature_mem_size}
\end{center}

\newpage

\subsection{Modul classifier}

Classifier modul obavlja klasifikaciju prozora, odnosno signalizira da li se na
trenutnom prozoru nalazi traženi objekat.
Zauzima najviše hardverskih resursa u sistemu i pored ii\_gen(\ref{ii_sii_gen_sec})
modula najviše utiče na performanse sistema.

\begin{figure}[H]
  \centering
  \scalebox{0.80}{
    \input{images/tikz/classifier.tex}
    }
\caption{Blok dijagram classifier modula.}
\label{classifier_bd}
\end{figure}

\newpage

Sledeći primeri u C-u približno opisuje algoritam rada klasifikatora.

\begin{lstlisting}[language=C++,caption={Weighted\_sum u \textbf{C}-u},captionpos=b, label=weighted_sum_code]
  int weights[RECT_NUM][FEATURE_NUM]; //feature weights
  int rects[RECT_NUM][FEATURE_NUM][4];//unpacked rect_coords

  long weighted_sum_i(int ii[FRAME_HEIGHT][FRAME_WIDTH],
                      int f,      // feature_num
                      int r){     // rect_num

    long sum = ii[rects[r][f][0][1]][rects[r][f][0][0]] +
               ii[rects[r][f][3][1]][rects[r][f][3][0]] -
               ii[rects[r][f][2][1]][rects[r][f][2][0]] -
               ii[rects[r][f][1][1]][rects[r][f][1][0]];
    sum *= weights[r][f];

    return sum;
  }
  long weighted_sum(int ii[FRAME_HEIGHT][FRAME_WIDTH],
                    int feature_num){
    long sum0 = weighted_sum_i(ii, feature_num, 0);
    long sum1 = weighted_sum_i(ii, feature_num, 1);
    long sum2 = weighted_sum_i(ii, feature_num, 2);

    return sum0 + sum1 + sum2;
  }
\end{lstlisting}

Primer \ref{weighted_sum_code} približno prikazuje algoritam rada weighted\_sum
komponente sa slike(\ref{classifier_bd}).
Memorije weights i rects se nalaze u features\_mem komponenti u hardveskoj
implementaciji i objašnjene su u sekciji(\ref{features_meme_sec}).\\

Funkcija weighted\_sum\_i() računa sumu piksela pravougaonika na integralnoj slici.
Kao na slici(\ref{IntegralImage_img2}) na integralnoj slici potrebno je sabrati
gornji levi i donji desni piksel zatim oduzeti gornji desni i donji levi
piksel.\\
Pošto svaki pravougaonik ulazi u konačan zbir sa nekom težinom potrebno je
pomnožiti sumu pravougaonika sa težinom kao u liniji 12. \\

Funkcija weighted\_sum() dodatno sabira težinske sume sva tri pravougaonika.

\newpage

\begin{lstlisting}[language=C++,caption={Leaf\_val u \textbf{C}-u},captionpos=b, label=leaf_val_code]
  int feature_thresholds[FEATURE_NUM];
  int leaf_val0[FEATURE_NUM];
  int leaf_val1[FEATURE_NUM];

  int leaf_val(long stddev,
               long sum,
               int feature_num){

    if(sum <= feature_thresholds[feature_num] * stddev)
        return leaf_val0[feature_num];
    else
        return leaf_val1[feature_num];
  }
\end{lstlisting}

Primer(\ref{leaf_val_code}) prikazuje algoritam računanja leaf\_val vrednosti. \\
Memorija feature\_thresholds se nalazi na slici(\ref{classifier_bd}) pod nazivom
feature\_thr ROM. \\
Memorije leaf\_val0 i leaf\_val1 su leafVal0 i leafVal1 na
slici(\ref{classifier_bd}). \\

Funkcija leaf\_val kao ulaz prima standardnu devijaciju prozora, težinsku sumu
sva tri pravougaonika i broj trenutnog obeležja. \\
Povratna vrednost ove funkcije je sadržaj jedne od memorija leaf\_val0 ili
leaf\_val1 za to obeležje. \\

Ukoliko je težinska suma manja od praga obeležja feature\_threshold
pomnoženog sa standardnom devijacijom, povratna vrednost će biti iz memeorije
leaf\_val0, u suprotnom povratna vrednost će biti iz memorije leaf\_val1.