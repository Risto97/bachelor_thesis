\section{Zaključak}

U ovom radu je uspešno projektovana arhitektura hardverskog akceleratora
Viola-Jones algoritma.
Performanse hardverskog rešenja nisu dostigle performanse OpenCV softverske
implementacije. \\

Predloženim optimizacijama moguće je dostići približne performanse OpenCV
implementacije.
Bolje performanse bi se postigle i korišćenjem većeg i kvalitetnijeg FPGA čipa,
na kojem bi se sistem implementirao sa višom frekvencijom takta.
U slučaju \gls{asic} implementacije moguće je dostići mnogo više
frekvencije rada, pa dobiti značajno brže rešenje od softverskog. \\

Tokom implementacije hardverske arhitekture korišćen je inovativni pristup opisa
hardvera korišćenjem PyGears metodologije.
Takođe ista arhitektura je implementirana i u standardnoj RTL SystemVerilog
implementaciji.
Zaključeno je da funkcionalni pristup koji nameće PyGears metodologija može
značajno ubrzati razvoj u nekim situacijama, dok je pojedine komponente
jednostavnije implementirati RTL metodologijom. \\

Nezavisno od metodologije pisanja hardvera, u jeziku višeg nivoa kao što je
Python dizajneru je na raspolaganju mnogo moderniji jezik od SystemVerilog-a.
Prednost se prvenstveno može primetiti prilikom generisanja IP jezgra na osnovu
apstraktnijih softverskih modela.\\
Jedna od veoma čestih primena hardverskih akceleratora je i u Machine Learning
industriji.
Poznato je da je Python jezik koji se najčešće koristi u ovoj industriji, pa je
generisanje parametrizovanog IP jezgra na osnovu Machine Learning modela značajno
jednostavnije opisom hardvera u Python-u. \\

Veliki problem svih novih HDL jezika predstavlja hardverska industrija i
akademska zajednica koja je spora u usvajanju novih tehnologija.
Postojanje velike količine ``legacy code''-a dodatno otežava prelazak na noviji
HDL jezik. \\
Pored toga velike EDA kompanije diktiraju standarde i jezike u industriji,
a one trenutno nemaju interesa za unapređivanju ovog aspekta digitalnog dizajna
zbog velike zarade od trenutnih alata. \\

U radu je uspešno implementiran sistem na Zynq SoC platformi, prilikom
čega je bilo potrebno napisati Linux Device Driver.
Isto tako i konfigurisati i kompajlirati U-Boot i Linux Kernel za potrebe
projektovanog embeded sistema. \\
Napisana korisnička aplikacija u dva hijerarhijska nivoa, omogućava jednostavnu
komunikaciju sa projektovanim Kernel Driver-om iz različitih programskih jezika.
U ovom slučaju najviši nivo hijerarhije korisničke aplikacije je napisan u
Python-u. \\